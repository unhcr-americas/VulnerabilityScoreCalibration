---
title: "3-Package Functions with Examples"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant

library(ggplot2)
library(tidyverse)
pkgload::load_all(export_all = FALSE)
```

# data

## Built-in Data

This includes the skeleton to build the 2 questionnaires in different languages

## Demo Data

The demo data includes the list of indicators/criteria in different langues

```{r}

readxl::read_excel( system.file("data-demo/indicator_criteria.xlsx", package = "VulnerabilityScoreCalibration"),
                            sheet = "indicator")  |>
  dplyr::filter( language == "English (en)") |>
  dplyr::select( dimension, indicator, indicator_hint)

```

The following dataset has been anonymized from one of the field implementation.

```{r}
kobodata <-  system.file("data-demo/quadra_data.xlsx", package = "VulnerabilityScoreCalibration")
koboform <-  system.file("data-demo/quadra_form.xlsx", package = "VulnerabilityScoreCalibration")


```

# Quadratic Voting

## quadratic_prepare

```{r function-quadratic_prepare}
#' quadratic_prepare
#' 
#' This function aims at quickly building a quadratic voting questionnaire
#' 
#' The questionnaire comes with limitation as it can process not more than 5 groups
#' of maximum 5 indicators. Each indicators is associated to different levels that
#' will be then assessed through conjoint analysis for the weighting stage
#' 
#' After quadratic voting, it is expected that the facilitation of the result 
#' interpretation should allow to reduce the numbers of indicators to a maximum of
#' 12 indicators
#' 
#' @param indicator a dataframe with max 5 groups of 5 indicators
#' 
#' @return
#' 
#' @export
quadratic_prepare <- function(){
    
}
```

```{r example-quadratic_prepare}

indicator <-  system.file("data-demo/indicator_criteria.xlsx", package = "VulnerabilityScoreCalibration")
quadratic_prepare()
```

```{r tests-quadratic_prepare}
test_that("quadratic_prepare works", {
  expect_true(inherits(quadratic_prepare, "function")) 
})
```

## mod_quadratic_prepare

```{r function-mod_quadratic_prepare}

#' quadratic_prepare UI Function
#'
#' @description A shiny Module.
#'
#' @param id,input,output,session Internal parameters for {shiny}.
#'
#' @noRd 
#'
#' @importFrom shiny NS tagList 
mod_quadratic_prepare_ui <- function(id){
  ns <- NS(id)
  tagList(
 
  )
}
    
#' quadratic_prepare Server Functions
#'
#' @noRd 
mod_quadratic_prepare_server <- function(id){
  moduleServer( id, function(input, output, session){
    ns <- session$ns
 
  })
}
    
## To be copied in the UI
# mod_quadratic_prepare_ui("quadratic_prepare_1")
    
## To be copied in the server
# mod_quadratic_prepare_server("quadratic_prepare_1")

```

```{r example-mod_quadratic_prepare}
#mod_quadratic_prepare()
```

```{r tests-mod_quadratic_prepare}
# testServer(
#   mod_quadratic_prepare_server,
#   # Add here your module params
#   args = list()
#   , {
#     ns <- session$ns
#     expect_true(
#       inherits(ns, "function")
#     )
#     expect_true(
#       grepl(id, ns(""))
#     )
#     expect_true(
#       grepl("test", ns("test"))
#     )
#     # Here are some examples of tests you can
#     # run on your module
#     # - Testing the setting of inputs
#     # session$setInputs(x = 1)
#     # expect_true(input$x == 1)
#     # - If ever your input updates a reactiveValues
#     # - Note that this reactiveValues must be passed
#     # - to the testServer function via args = list()
#     # expect_true(r$x == 1)
#     # - Testing output
#     # expect_true(inherits(output$tbl$html, "html"))
# })
#  
# test_that("module ui works", {
#   ui <- mod_quadratic_prepare_ui(id = "test")
#   golem::expect_shinytaglist(ui)
#   # Check that formals have not been removed
#   fmls <- formals(mod_quadratic_prepare_ui)
#   for (i in c("id")){
#     expect_true(i %in% names(fmls))
#   }
# })
 

```

## quadratic_review

```{r function-quadratic_review}
#' quadratic_review
#' 
#' Explore the results from a quadratic voting consultations. 
#'  1. What are the prioritized Topics?
#'  2. How dispersed participants votes are? 
#'  3. Who is expecting or pushing back... on what? 
#'  
#' @param kobodata path to data collected through kobotoolbox
#' @param koboform form used to collected through kobotoolbox quadratic survey
#' 
#' 
#' @importFrom ggridges geom_density_ridges
#' @importFrom unhcrthemes theme_unhcr
#' @importFrom readxl read_excel
#' @importFrom dplyr arrange select rename  
#'                group_by first
#'                left_join filter mutate
#' @importFrom forcats fct_reorder	
#' @importFrom tidyselect starts_with
#' @import ggplot2
#' @return list with data and standard plots
#' 
#' @export
quadratic_review <- function(kobodata, koboform){
  
  ## load data
  ind <- readxl::read_excel( kobodata,
                            sheet = 1)
  data <- readxl::read_excel(kobodata,
                       sheet = "positions")
  
  ## load info from the form
  positions <- readxl::read_excel(koboform,
                       sheet = "positions") |>
    dplyr::select(topic, name) |>
    dplyr::rename(groups.positions.pos_name = name)
  
  choices <- readxl::read_excel(koboform,
                       sheet = "choices") |>
    ## Rename and use what ever label set is coming first 
    dplyr::rename(label = dplyr::first(tidyselect::starts_with("label")) )
  
  
  ## Check who did not reply
  #part1 <- part |>
  # dplyr::left_join(ind, by = c( "email" )) |>
  # dplyr::filter(is.na(start))
  
  ## Check matching
  ind2 <- ind
  
  data11 <- data |>
    ## filter by suboffice
    ## filter(is.na("_submission__validation_status")) |>
    ## Add theme
    dplyr::left_join(positions) |>
    ## Add Participant info
    dplyr::left_join(ind2, by = c("_submission__uuid" = "_uuid")) |>
    
    dplyr::filter(!(is.na(groups.positions.votes)))
  
  data1 <- data11 |>
    dplyr::select(
      email,
      topic,
      groups.positions.pos_name,
      groups.positions.pos_text,
      groups.positions.votes,
      groups.positions.vote_cost
    ) |>
    dplyr::mutate(
      position = paste0(groups.positions.pos_text),
      groups.positions.votes = as.numeric(groups.positions.votes),
      groups.positions.vote_cost = as.numeric(groups.positions.vote_cost)
    ) |>
    dplyr::group_by(position,
             groups.positions.pos_name,
             groups.positions.pos_text) |>
    dplyr::summarise(
      cnt = dplyr::n(),
      vote = sum(groups.positions.votes),
      votemean = mean(groups.positions.votes),
      votesd = sd(groups.positions.votes),
      votecost = sum (groups.positions.vote_cost)
    )  |>
    dplyr::arrange(desc(vote))
  
  ## Reshpe the data to merge votes
  df <- data |>
    ## Add theme
    dplyr::left_join(positions) |>
    ## Add Participant info
    dplyr::left_join(ind2, by = c("_submission__uuid" = "_uuid")) |>
    dplyr::filter(!(is.na(groups.positions.votes))) |>
    dplyr::filter(!(is.na(email))) |>
    dplyr::select(
      email,
      topic,
      groups.positions.pos_name,
      groups.positions.pos_text,
      groups.positions.votes,
      groups.positions.vote_cost
    ) |>
    dplyr::mutate(
      position = paste0(groups.positions.pos_text),
      posit = paste0(topic, "-", groups.positions.pos_name),
      groups.positions.votes = as.numeric(groups.positions.votes),
      groups.positions.vote_cost = as.numeric(groups.positions.vote_cost)
    ) |>
    dplyr::mutate(
      groups.positions.pos_text = forcats::fct_reorder(.f = groups.positions.pos_text,
                                              .x = groups.positions.vote_cost,
                                              .fun = mean)
    ) |>
    dplyr::mutate(position = forcats::fct_reorder(.f = position,
                                         .x = groups.positions.vote_cost,
                                         .fun = mean)) |>
    dplyr::mutate(posit  = forcats::fct_reorder(.f = posit ,
                                       .x = groups.positions.vote_cost,
                                       .fun = mean))
  
  
  ## What are the prioritized Topics?
  p <- ggplot(data1) +
    aes(x = reorder(position, vote),
        fill = votesd,
        weight = vote) +
    geom_bar() +
    #  scale_fill_viridis_c(option = "inferno", direction = 1) +
    scale_fill_distiller(palette = "Oranges", direction = -1) +
    coord_flip() +
    unhcrthemes::theme_unhcr(font_size = 14)  +
    theme(
      panel.grid.major.x  = element_line(color = "#cbcbcb"),
      panel.grid.major.y  = element_blank(),
      panel.grid.minor = element_blank()
      # legend.position= "none"
    ) +
    labs(
      title = "Validaci\u00f3n de indicadores para ser puntuados en el Scorecard de elegiblidad",
      subtitle = "Adicional al n\u00famero total de votos, tambi\u00e9n podemos ver el nivel de acuerdo por colores: entre m\u00e1s oscuro m\u00e1s consenso...",
      x = "",
      y = "",
      caption = paste0(
        "Data recolectada a trav\u00e9s de votaci\u00f3n cuadr\u00e1tica- # de participantes es ",
        nrow(ind |> dplyr::filter(!(is.na(
          email
        ))))
      )
    )
  
  ## How dispersed participants votes are?
  p2 <- ggplot(df,
               aes(x = groups.positions.votes,
                   y = position)) +
    ggridges::geom_density_ridges(fill = "#00AFBB",
                        rel_min_height = 0.01,
                        alpha = 0.7) +
    unhcrthemes::theme_unhcr(font_size = 14)  +
    theme(
      panel.grid.major.x  = element_line(color = "#cbcbcb"),
      panel.grid.major.y  = element_blank(),
      panel.grid.minor = element_blank()
    ) +
    labs(
      title = "Dispersion of votes on indicators to prioritize",
      x = "",
      y = "",
      caption = paste0(
        "Data collected through a quadratic voting survey. # of participants to the consultation is    ",
        nrow(ind |> dplyr::filter(!(is.na(
          email
        ))))
      )
    )
  
  ## Who is expecting (or pushing back...) on what?
  p3 <- ggplot(df) +
    aes(x = reorder(posit, groups.positions.votes),
        y = groups.positions.votes) +
    geom_bar(stat = "identity" ,
                   fill = "#0072BC") +
    facet_wrap(~ email, nrow = 3) +
    coord_flip() +
    unhcrthemes::theme_unhcr(font_size = 14)  +
    theme(
      panel.grid.major.x  = element_line(color = "#cbcbcb"),
      panel.grid.major.y  = element_line(color = "#e1e1e1"),
      panel.grid.minor = element_blank(),
      legend.position = "none",
      panel.spacing = unit(0.1, "lines"),
      strip.background = element_rect(
        color = "black",
        size = 1.5,
        linetype = "solid"
      )
    ) +
    labs(
      title = "Individual Prioritisation of indicators to score",
      x = "",
      y = "",
      caption = paste0(
        "Data collected through a quadratic voting survey. # of participants to the consultation is  ",
        nrow(ind |> dplyr::filter(!(is.na(
          email
        ))))
      )
    )
  
  #p3
  results <- list(df =df,
                  topic_prioritisation = p,
                  vote_dispersion = p2,
                  individual_prioritisation = p3)
  return(results)
    
}
```

```{r example-quadratic_review}

# kobodata <- here::here("", "quadra_data.xlsx")
# koboform <- here::here("", "survey_quadraticvoting_CBI_Indicators.xlsx")

kobodata <-  system.file("data-demo/quadra_data.xlsx", package = "VulnerabilityScoreCalibration")
koboform <-  system.file("data-demo/quadra_form.xlsx", package = "VulnerabilityScoreCalibration")
 
## Run the process
result <- quadratic_review(kobodata, koboform)

## Review output
result[["topic_prioritisation"]]

result[["vote_dispersion"]]

result[["individual_prioritisation"]]

```

```{r tests-quadratic_review}
test_that("quadratic_review works", {
  expect_true(inherits(quadratic_review, "function")) 
})
```

## mod_quadratic_review

Below is a golem module to make the function available within the shiny App

```{r function-mod_quadratic_review}

#' quadratic_review UI Function
#'
#' @description A shiny Module.
#'
#' @param id,input,output,session Internal parameters for {shiny}.
#'
#' @noRd 
#'
#' @importFrom shiny NS tagList 
mod_quadratic_review_ui <- function(id){
  ns <- NS(id)
  tagList(
 
  )
}
    
#' quadratic_review Server Functions
#'
#' @noRd 
mod_quadratic_review_server <- function(id){
  moduleServer( id, function(input, output, session){
    ns <- session$ns
 
  })
}
    
## To be copied in the UI
# mod_quadratic_review_ui("quadratic_review_1")
    
## To be copied in the server
# mod_quadratic_review_server("quadratic_review_1")

```

```{r example-mod_quadratic_review}
#mod_quadratic_review()
```

```{r tests-mod_quadratic_review}
# testServer(
#   mod_quadratic_review_server,
#   # Add here your module params
#   args = list()
#   , {
#     ns <- session$ns
#     expect_true(
#       inherits(ns, "function")
#     )
#     expect_true(
#       grepl(id, ns(""))
#     )
#     expect_true(
#       grepl("test", ns("test"))
#     )
#     # Here are some examples of tests you can
#     # run on your module
#     # - Testing the setting of inputs
#     # session$setInputs(x = 1)
#     # expect_true(input$x == 1)
#     # - If ever your input updates a reactiveValues
#     # - Note that this reactiveValues must be passed
#     # - to the testServer function via args = list()
#     # expect_true(r$x == 1)
#     # - Testing output
#     # expect_true(inherits(output$tbl$html, "html"))
# })
#  
# test_that("module ui works", {
#   ui <- mod_quadratic_review_ui(id = "test")
#   golem::expect_shinytaglist(ui)
#   # Check that formals have not been removed
#   fmls <- formals(mod_quadratic_review_ui)
#   for (i in c("id")){
#     expect_true(i %in% names(fmls))
#   }
# })
 

```

# Conjoint Analysis

## conjoint_prepare

```{r function-conjoint_prepare}
#' conjoint_prepare
#' 
#' Generate an xlsform used to perform consultation for conjoint analysis.
#' 
#' The options that will be compared are the different levels of the section 
#' of indicators that should have been filtered through the quadratic voting 
#' stage.
#' 
#' One level can actually match multiple response options from the screening 
#' questionnaire 
#' 
#' @param opts a dataframe containing the options to compare
#' @param language
#' @param form_title  Actividad #2: Calificación de perfiles de vulnerabilidad 
#' @param id_string vulnerability_rating
#' @param outdir   
#' @param outfile
#' 
#' @return a file in xlsform format
#' 
#' @importFrom readr read_csv
#' @importFrom writexl write_xlsx
#' @importFrom dplyr group_by group_map tibble
#' @importFrom conjoint caFactorialDesign
#' @importFrom tidyr expand_grid
#' @importFrom purrr map imap pmap_dfr
#' @importFrom rlang list2 set_names
#' @export
conjoint_prepare <- function(opts,language, form_title, id_string , outdir , outfile ){

  ## is in package
#survey <- readr::read_csv("conjointSurvey.csv")
#choices <- read_csv("conjointChoices.csv")
  
## Build the profiles using a factorial design  
profiles <-  opts |>
  nest(data = -dim) |>
  (\(x) rlang::set_names(x$data, x$dim))() |>
  purrr::map( ~ dplyr::group_map( dplyr::group_by(., measure),
                   ~ rlang::list2(!!.y$measure := .x$level)) |>
         purrr::flatten() |>
         (\(x) tidyr::expand_grid(!!!x))()) |>
  purrr::map( ~ conjoint::caFactorialDesign(., type = "fractional")) |>
  purrr::imap( ~ purrr::pmap_dfr(
    .,
    ~ dplyr::tibble(
      type = "select_one scale",
      appearance = "horizontal-compact",
      required = TRUE,
      label = str_c(..., sep = "\n")
    )
  ) |>
    dplyr::mutate(name = str_c(.y, row_number(), sep = "_"), .before = 1)) |>
  purrr::imap( ~ bind_rows(
    list(type = "begin_group", name = .y, label = .y),
    .x,
    list(type = "end_group")
  )) |>
  dplyr::bind_rows()

## build the survey part
survey <-  dplyr::bind_rows(
    survey |> 
      slice_head(n = detect_index(survey$name,
                                  ~ replace_na(. == "p", FALSE))),
    profiles,
    survey |> slice_tail(n = -detect_index(survey$name, 
                                           ~ replace_na(. == "p", FALSE)))
  )

## Define the settings
settings <-  dplyr::tibble(form_title = form_title,
         id_string = id_string,
         style = "theme-grid")

writexl::write_xlsx(
  list(
    survey = survey,
    choices = choices,
    settings = settings
  ),
  path = here::here(outdir, oufile),
  format_headers = FALSE
)
    
}
```

```{r example-conjoint_prepare}


# indicator <-  system.file("data-demo/indicator_criteria.xlsx", package = "VulnerabilityScoreCalibration")
# opts <- read_excel("cja_opts_SAL.xlsx")
# 
# conjoint_prepare( opts = opts, 
#                   language = "Spanish (es)",
#                   form_title = "Actividad #2: Calificación de perfiles de vulnerabilidad - El Salvador, 23 de marzo, 2023",
#                   id_string = "vulnerability_rating",
#                   outdir = "", 
#                   outfile = "form.xlsx" )
```

```{r tests-conjoint_prepare}
test_that("conjoint_prepare works", {
  expect_true(inherits(conjoint_prepare, "function")) 
})
```

## mod_conjoint_prepare

```{r function-mod_conjoint_prepare}

#' conjoint_review UI Function
#'
#' @description A shiny Module.
#'
#' @param id,input,output,session Internal parameters for {shiny}.
#'
#' @noRd 
#'
#' @importFrom shiny NS tagList 
mod_conjoint_prepare_ui <- function(id){
  ns <- NS(id)
  tagList(
 
  )
}
    
#' conjoint_review Server Functions
#'
#' @noRd 
mod_conjoint_prepare_server <- function(id){
  moduleServer( id, function(input, output, session){
    ns <- session$ns
 
  })
}
    
## To be copied in the UI
# mod_conjoint_prepare_ui("conjoint_prepare_1")
    
## To be copied in the server
# mod_conjoint_prepare_server("conjoint_prepare_1")

```

```{r example-mod_conjoint_prepare}
#mod_conjoint_prepare()
```

```{r tests-mod_conjoint_prepare}
# testServer(
#   mod_conjoint_prepare_server,
#   # Add here your module params
#   args = list()
#   , {
#     ns <- session$ns
#     expect_true(
#       inherits(ns, "function")
#     )
#     expect_true(
#       grepl(id, ns(""))
#     )
#     expect_true(
#       grepl("test", ns("test"))
#     )
#     # Here are some examples of tests you can
#     # run on your module
#     # - Testing the setting of inputs
#     # session$setInputs(x = 1)
#     # expect_true(input$x == 1)
#     # - If ever your input updates a reactiveValues
#     # - Note that this reactiveValues must be passed
#     # - to the testServer function via args = list()
#     # expect_true(r$x == 1)
#     # - Testing output
#     # expect_true(inherits(output$tbl$html, "html"))
# })
#  
# test_that("module ui works", {
#   ui <- mod_conjoint_prepare_ui(id = "test")
#   golem::expect_shinytaglist(ui)
#   # Check that formals have not been removed
#   fmls <- formals(mod_conjoint_prepare_ui)
#   for (i in c("id")){
#     expect_true(i %in% names(fmls))
#   }
# })
 
```

## conjoint_review

```{r function-conjoint_review}
#' conjoint_review
#' 
#'  What is Conjoint analysis?
#'  
#'  Conjoint analysis can speed up expert consultations by offering an 
#'  __objective mean to compile expert opinions__.
#'  
#'  * Conjoint analysis originated in mathematical psychology by psychometricians.
#'  
#'  * often used to evaluate how people make decisions between a set of 
#'  different options when considering a number of criteria at the same time 
#'  (conjoint features; “trade-offs”). 
#'  
#'  1. Measurement framework
#'  
#'  The [Joint Intersectoral Analysis Framework (JIAF)](https://interagencystandingcommittee.org/system/files/gbna_tools_and_guidance_pkg_final_june_2019.pdf) 
#'  is a theoretical generic measurement framework to be used for Humanitarian 
#'  needs assessment. It specifies three distinct and complementary components
#'   of humanitarian severity and vulnerability indexes:
#'    
#'  * Basic Needs & Living standards  
#'  
#'  * Coping Capacity
#'  
#'  * Well Being & Community integration
#'  
#'  This generic model can be contextualised: different sub-indicators might be 
#'  used for each of the 3 components depending on cultural and political situations. 
#'  
#'  2. Define the combined alternatives to be compared 
#'  
#'  * participants rate their preferences for profiles with different combinations
#'   of the attributes or criteria. 
#'  
#'  * CA then allows to “decompose” or reverse-engineer these ratings into
#'   estimates of how important each criteria or attribute is to a participant’s ranking decisions
#'  
#'  3. Utility scales & Agreement levels
#'  
#'  Estimating the contribution of each potential answers
#'  
#'  * Utility values indicate the overall contribution of each attribute to how 
#'  the profiles were rated (e.g. whether number of meals is more important in 
#'  vulnerability scoring than access to safe water). 
#'  
#'  * A higher _"utility"_ estimate indicates that this level contributes to a
#'   higher vulnerability than the level with the lower utility estimate 
#'   (it does not give an absolute value for the utility of an option, but rather
#'    assumes a reference alternative). 
#'  
#'  * Standard deviation for each level within model allows to better understand 
#'  how homogeneous the group of experts is with respect to one level.  
#'  
#'  4. Importance of each criteria 
#'  
#'   * Importance of each criteria represent the average importance as estimated from all experts.
#'  
#'   * Importance values will then be used as the weights for each attribute inside each of our three dimensions. 
#'  
#'   * Importance values sum to 100%. 
#'   
#' @import ggplot2
#' @importFrom unhcrthemes theme_unhcr
#' @import survival
#' @import sandwich
#' @import conjoint
#' @importFrom readxl read_excel
#' @importFrom stringr str_c str_replace str_match
#' @importFrom purrr compose
#' @importFrom tidyr separate_rows nest pivot_longer  pivot_wider
#' @importFrom cregg cj mm
#' @importFrom stats mahalanobis
#' @importFrom forcats as_factor
#' @importFrom lubridate as.duration
#' @importFrom tidyselect starts_with
#' @importFrom  dplyr select mutate distinct transmute
#'                    with_groups  as_tibble rowwise
#'                   arrange row_number anti_join first
#'                   across everything where summarize
#' 
#' @return a series of plot
#' 
#' @export
conjoint_review <- function(kobodata, koboform){
   ## load data
  data <- readxl::read_excel(kobodata,
                       sheet = 1)
  
  ## load info from the form
  form <- readxl::read_excel(koboform,
                       sheet = "survey") |>
    ## Rename and use what ever label set is coming first 
    dplyr::rename(label = dplyr::first(tidyselect::starts_with("label")),
                  hint = dplyr::first(tidyselect::starts_with("hint")))
  
  opts <- readxl::read_excel(koboform,
                       sheet = "opts")
  
  
   opts <- opts |> 
     dplyr::mutate(dplyr::across(dplyr::everything(), 
                          stringr::str_replace, "\r", ""))
  
  dict <- opts |>
    dplyr::distinct(dim, measure) |>
    dplyr::arrange(dim, measure) |>
    dplyr::with_groups(dim, 
                       mutate, 
                       feature = stringr::str_c("v", 
                                                dplyr::row_number()))
  
  scores <- data |>
    dplyr::select(email, starts_with("p.")) |>
    tidyr::pivot_longer(-email, names_to = "var")
  
  dims <- data |>
    dplyr::select(starts_with("p.")) |>
    names() |>
    stringr::str_match("p\\.(.+)\\.(.+)") |>
    dplyr::as_tibble(.name_repair = "universal") |>
    dplyr::rename(var = ...1, dim = ...2, lvl = ...3) |>
    dplyr::left_join(form |> 
                       dplyr::select(lvl = name, label = `label`), 
                     by = "lvl") |>
    tidyr::separate_rows(label, sep = "\\n") |>
    dplyr::with_groups(lvl, mutate, 
                       feature = stringr::str_c("v", 
                                                dplyr::row_number())) |>
    dplyr::left_join(dict) |> 
    dplyr::select(-feature) |>
    tidyr::pivot_wider(names_from = measure, values_from = label) |>
    dplyr::mutate(dplyr:::across(-c(var:lvl), forcats::as_factor)) 

#uncommented as_factor
#   ~factor(., levels = opts |> filter(measure == cur_column()) |> pull(level)))) 

  cjdata <-  dplyr::left_join(dims, scores, by = "var") |>
    tidyr::nest(data = -dim) |>
    dplyr::rowwise() |>
    dplyr::mutate(
      data = data |> 
        select(- purrr::compose( purrr::compose(all, is.na))) |> 
        list(),
      formula =
        data |>
        dplyr::select(where(is.factor)) |>
        names() |>
        stringr::str_c(collapse = "+") |>
        stringr::str_c("value", 
                       vars = _, 
                       sep = "~"),
        margins = cregg::mm(data, as.formula(formula), id = ~ email) |> 
        list(),
      amces =
        cregg::cj(data, 
                  as.formula(formula),
                  id = ~ email) |>
        dplyr::group_by(feature) |>
        dplyr::mutate(
          normalized = (estimate - min(estimate)) / (max(estimate) - min(estimate)),
          horizontal = (estimate - min(estimate)),
          normalized1p = normalized + 1,
          horizontal1p = horizontal + 1 ) |> 
        dplyr::ungroup() |> 
        list(),
      importance =
        dplyr::as_tibble(amces) |>
        dplyr::mutate(
          estimate = abs(estimate) / sum(abs(estimate)),
          lower = abs(lower) / sum(abs(lower), na.rm = TRUE),
          upper = abs(upper) / sum(abs(upper), na.rm = TRUE)  ) |> 
        list()
    )


  ##This is where cleaning is reported, identifying cases for deletion. 
  
  #FOR TIME: It is recommended that experts complete the survey during the live exercise. 
  # A good window of time is between 10-90 minutes. Cases that were completed faster
  #or slower than this should be considered for deletion. 
  #This code generated the table of flagged entries. click on 'expert_validation'
  #on the Environment to see the table. If you identify any entry flagged as suspect,
  #but that you still want to keep, change the reference values 10 or 90. 
  time_validation <-  data |>
    dplyr::transmute(
      email,
      dur = lubridate::as.duration(end - start) |> 
        as.numeric("minutes"),
      too_short = dur < 10,
      too_long = dur > 90,
      suspect = too_short | too_long
    )
  # View(time_validation)
  data <- data |> 
      dplyr::anti_join(time_validation |> 
                         dplyr::filter(suspect), 
                       by = "email")

  #FOR DUPLICATE ENTIRES: Cleaning for duplicates based on name of expert.
  
  #this identifies duplicates by name. Look and manually choose which to keep.
  # expertdups <-   data |> 
  #   dplyr::semi_join(count(., email) |> 
  #                      dplyr::filter(n > 1)) 
  #Example manual cleaning.
  # data <-
  #   data[!(data$"_id" %in% c("26964652")),] 
  
  # 1 duplicate entries. Kept shortest time. Eliminated _id is 26964652. 
  # Kept entry's _id is 26964599


  #FOR OUTLIERS: Screen for data quality.
  #Spot repetitive responses (example: answered all options with '3'), responses 
  # with little variance (all answers between 6-7, standard deviation less than 2). 
  # Also looks for averages that are very different from the rest of the responses.
  # For example, someone's average score is 2 when the rest of the scores are 
  # between 6-7. Analysis can be repeated with and without this case to test and 
  # compare how it influences the results. 
   
  
  #spotting outliers using Mahalanobis distance. 
  mah.data <-   data |> 
    dplyr::select(starts_with("p.")) |> 
    dplyr::select(where(is.numeric))


  #just added this ", tol=1e-21" right after cov(.). After error message:
  #"system is computationally singular: reciprocal condition number = 4.08252e-20 
  #Input `mah.dist` is `mah.data |> mahalanobis(., center = colMeans(.), cov = cov(.))`.

  # expert <-  data |> 
  #   mutate(mah.dist = mah.data |> 
  #            stats::mahalanobis( .,  
  #                                center = colMeans(.), 
  #                                cov = cov(.), 
  #                                tol = 1e-21 )) 

#Cutoff point of probability, can be modified. .99 extreme outliers, .95, .90, etc. 
#data <- data |> anti_join(outliers, by = "_id") 

#filters the identified out.
#PANAMA: V1 of the analysis - 4 outliers identified at .95, .97 and .99 levels (same 4 outliers). But they belonged to experts considered of good opinion. Analysis was run first including all outliers. In this analysis, for "Coping Capacities, there were higher levels of discrepancy. Where the dot was outside of the lines. There was also no differences between the levels of "type of household head". 
#PANAMA: analysis was run a second time removing all 4 outliers. The results were the same. Outliers were mantained. 
#PANAMA: V2 of the analysis - 2 outliers were detected at .95, .97 and 1 detected at the .99 level (the 1 outlier was included in all probability levels. It was decided to keep the outlier. 

  # outliers <- expert |> 
  #   dplyr::filter(mah.dist > qchisq(.99, 
  #                                   df = ncol(mah.data))) 
  # 
  # nexpert <- n_distinct(data$email)
  #names(expert)

  ## Data Quality Viz
  plot1 <- data |>
    ggplot(aes(as.numeric(survey_mins))) +
    geom_histogram(color = "white", 
                   fill = "#0072BC") +
    scale_y_continuous(expand = expansion(0, 0)) +
    labs(title = "Times to complete the consultation",
         x = "minutes", y = "# of participants") +
    unhcrthemes::theme_unhcr()
  
  plot2 <- data |>
    dplyr::summarize(mean = rowMeans(data |> 
                                       dplyr::select(starts_with("p.")))) |>
    ggplot(aes(mean)) +
    geom_histogram(colour = "white",
                   fill = "#0072BC",
                   binwidth = 1) +
    scale_y_continuous(expand = expansion(0, 0)) +
    labs(title = "Average score",
         x = "", y = "# de participantes") +
    unhcrthemes::theme_unhcr()

  require(patchwork)
  p <- plot1 + plot2 + plot_annotation(caption = glue::glue("Based on {nrow(data)} consultations"))

  results <- list(
    data =  data,
    cjdata = cjdata,
    data_quality = p
  )
   return(results)
}
```

```{r example-conjoint_review}

kobodata <-  system.file("data-demo/conjoint_data.xlsx", package = "VulnerabilityScoreCalibration")
koboform <-  system.file("data-demo/conjoint_form.xlsx", package = "VulnerabilityScoreCalibration") 

cj <- conjoint_review(kobodata, koboform)

cj[["data_quality"]]
```

```{r tests-conjoint_review}
test_that("conjoint_review works", {
  expect_true(inherits(conjoint_review, "function")) 
})
```

## conjoint_plot_point 

```{r function-conjoint_plot_point}
#' conjoint_plot_point
#' 
#' Plot results per dimension - Marginal Means
#' 
#' @param .x
#' @return gggplot2 graph
#' @import ggplot2
#' @importFrom unhcrthemes theme_unhcr
#' @importFrom stringr str_wrap
#' 
#' @export

conjoint_plot_point <- function(.x) {
    ggplot(.x,
           aes(estimate, 
               level, 
               xmin = lower, 
               xmax = upper)) +
      geom_pointrange() +
      scale_y_discrete(labels = \(x) stringr::str_wrap(x, 80)) +
      facet_wrap(vars(feature), ncol = 1, 
                 scales = "free_y") +
      labs(
        caption = glue::glue(
          "Las l\u00edneas alado de los puntos representan el intervalo de confianza.",
          "(Entre m\u00e1s corta la l\u00ednea, hubo m\u00e1s acuerdo entre participantes.)",
          .sep = "\n"
        ),
        x = NULL,
        y = NULL
      ) +
      unhcrthemes::theme_unhcr() +
      theme(plot.caption = element_text(hjust = 1))
  }
```

```{r example-conjoint_plot_point}

kobodata <-  system.file("data-demo/conjoint_data.xlsx", package = "VulnerabilityScoreCalibration")
koboform <-  system.file("data-demo/conjoint_form.xlsx", package = "VulnerabilityScoreCalibration") 

cj <- conjoint_review(kobodata, koboform)
 
conjoint_plot_point( as.data.frame(cj[["cjdata"]][1,][["margins"]])) + 
  ggplot2::labs( subtitle = "Margins)")

conjoint_plot_point( as.data.frame(cj[["cjdata"]][1,][["amces"]])) + 
  ggplot2::labs( subtitle = "Average Marginal Component Effects (AMCEs)")

conjoint_plot_point( as.data.frame(cj[["cjdata"]][1,][["importance"]])) + 
  ggplot2::labs( subtitle = "Importance")
```

```{r tests-conjoint_plot_point}
test_that("conjoint_plot_point works", {
  expect_true(inherits(conjoint_plot_point, "function")) 
})


```

## conjoint_plot_bar - Average Marginal Component Effects (AMCEs)

```{r function-conjoint_plot_bar}
#' conjoint_plot_bar
#' 
#' Plot results per dimension - Average Marginal Component Effects (AMCEs)
#' 
#' @param .x
#' @return gggplot2 graph
#' @import ggplot2
#' @importFrom unhcrthemes theme_unhcr
#' @importFrom stringr str_wrap
#' 
#' @return
#' 
#' @export
conjoint_plot_bar <- function(.x) {
    ggplot(.x, aes(horizontal,
                   level, 
                   label = round(horizontal, 2))) +
      geom_col(fill = "#0072BC") +
      geom_label() +
      scale_y_discrete(labels = \(x) stringr::str_wrap(x, 90)) +
      facet_wrap(vars(feature), ncol = 1, scales = "free_y") +
      unhcrthemes::theme_unhcr() +
      theme(plot.caption = element_text(hjust = 1))
  }
```

```{r example-conjoint_plot_bar}

kobodata <-  system.file("data-demo/conjoint_data.xlsx", package = "VulnerabilityScoreCalibration")
koboform <-  system.file("data-demo/conjoint_form.xlsx", package = "VulnerabilityScoreCalibration") 

cj <- conjoint_review(kobodata, koboform)
 
## Plot AMCES as bar for dimension 2
conjoint_plot_bar( as.data.frame(cj[["cjdata"]][2,][["amces"]])) + 
  ggplot2::labs( subtitle = "Average Marginal Component Effects (AMCEs)")

## Plot importance as bar for dimension 2
conjoint_plot_bar( as.data.frame(cj[["cjdata"]][2,][["importance"]])) + 
  ggplot2::labs( subtitle = "Importance")
```

```{r tests-conjoint_plot_bar}
test_that("conjoint_plot_bar works", {
  expect_true(inherits(conjoint_plot_bar, "function")) 
})
```

## conjoint_walk - Summary by dimension

```{r function-conjoint_walk}
#' conjoint_walk 
#' 
#' Print out a summary from the conjoint analysis  
#' 
#'   *  Marginal Means
#' 
#'   *  Average Marginal Component Effects (AMCEs)
#' 
#'   *  Average Marginal Component Effects (AMCEs)
#' 
#'   *  Importance Weights
#' 
#' @param dim
#' @param margins
#' @param amces
#' @param importance
#' 
#' @importFrom glue glue
#' 
#' @return
#' 
#' @export
conjoint_walk <- function(dim, margins, amces, importance, ...) {
    cat("---\n\n")
    cat(glue::glue("{dim}\n\n"))
    cat("---\n\n")
    cat("## Average Marginal Component Effects (AMCEs) - Bar \n\n")
    print(conjoint_plot_bar(amces) + labs(title = dim, subtitle = "Average Marginal Component Effects (AMCEs)"))
    cat("\n\n")
    cat("## Average Marginal Component Effects (AMCEs) - Point \n\n")
    print( conjoint_plot_point(amces) + labs(title = dim, subtitle = "Average Marginal Component Effects (AMCEs)") )
    cat("\n\n")
    cat("## Marginal Means\n\n")
    print(conjoint_plot_point(margins) + labs(title = dim, subtitle = "Marginal Means"))
    cat("\n\n")
    cat("## Importance Weights\n\n")
    print(conjoint_plot_point(importance) + 
            scale_x_continuous(labels = scales::label_percent()) + 
            labs(title = dim, subtitle = "Importance Weights")  )
    cat("\n\n")
  }
```

```{r example-conjoint_walk}
kobodata <-  system.file("data-demo/conjoint_data.xlsx", package = "VulnerabilityScoreCalibration")
koboform <-  system.file("data-demo/conjoint_form.xlsx", package = "VulnerabilityScoreCalibration") 

cj <- conjoint_review(kobodata, koboform) 
cjdata <- cj[["cjdata"]]
## Get a summary of all dimensions
purrr::pwalk(cjdata, conjoint_walk)

## Save a csv extract of the weights
# purrr::walk2(cjdata$dim, cjdata$amces, ~write_csv(.y, fs::path(.x, ext = "csv")))
```

```{r tests-conjoint_walk}
test_that("conjoint_walk works", {
  expect_true(inherits(conjoint_walk, "function")) 
})
```

## mod_conjoint_review

```{r function-mod_conjoint_review}

#' conjoint_review UI Function
#'
#' @description A shiny Module.
#'
#' @param id,input,output,session Internal parameters for {shiny}.
#'
#' @noRd 
#'
#' @importFrom shiny NS tagList 
mod_conjoint_review_ui <- function(id){
  ns <- NS(id)
  tagList(
 
  )
}
    
#' conjoint_review Server Functions
#'
#' @noRd 
mod_conjoint_review_server <- function(id){
  moduleServer( id, function(input, output, session){
    ns <- session$ns
 
  })
}
    
## To be copied in the UI
# mod_conjoint_review_ui("conjoint_review_1")
    
## To be copied in the server
# mod_conjoint_review_server("conjoint_review_1")

```

```{r example-mod_conjoint_review}
#mod_conjoint_review()
```

```{r tests-mod_conjoint_review}

```

# mod_home

```{r function-mod_home}
#' home UI Function
#'
#' @description A shiny Module.
#'
#' @param id,input,output,session Internal parameters for {shiny}.
#'
#' @noRd 
#'
#' @importFrom shiny NS tagList 
mod_home_ui <- function(id){
  ns <- NS(id)
 tagList( 
        #Jumbotrons are pretty, they make nice headers
                  tags$div(class = "jumbotron text-left", 
                           style = "margin-bottom:15px;margin-top:15px;margin-left:15px",
                          fluidRow(
                            column( 10, 
                                    tags$h1(style = 'color:#0072BC;',
                                                style = 'margin-bottom:0px;margin-top:0px',
                                                'Consulting Experts')),
                            column( 2, 
                                    tags$i(style = 'font-size: 12rem;color:#0072BC;',
                                           class = "fa-solid fa-stethoscope")
                                    )
                          ) ,
                          fluidRow(
                            column( 4,  
                                    tags$h3(class = 'jumbotron-heading', 
                                                style = 'margin-left:25px',
                                                ' \"  ' ),
                                    tags$h3(class = 'jumbotron-heading', 
                                            style = 'margin-left:25px',
                                            '  \"')),
                            column( 8, 
                                    tags$p(class = 'jumbotron-heading', 
                                            style = 'margin-left:25px',
                                            '  ' ),
                                    tags$p(class = 'jumbotron-heading', 
                                            style = 'margin-left:25px',
                                            '  ' )
                                    )
                          ) 
                   ), ## end jumbotron..
                  
                  br(),
                  br(),
                    p('  App content')
                
  )
}
    
#' home Server Functions
#'
#' @noRd 
mod_home_server <- function(id){
  moduleServer( id, function(input, output, session){
    ns <- session$ns
 
  })
}
    
## To be copied in the UI
# mod_home_ui("home_1")
    
## To be copied in the server
# mod_home_server("home_1")
```

```{r example-mod_home}
#mod_home()
```

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/package_functions.Rmd",
               check = TRUE,
               document = TRUE,
               overwrite = TRUE, 
               vignette_name = "3-Package Functions with Examples")
```
